apiVersion: v1
data:

  livenessProbe.sh: |
    #!/bin/bash
    # Kubernetes periodically calls this liveness probe script to determine whether
    # the pod should be restarted. The script checks a WebLogic Server state file which
    # is updated by the node manager.
    STATEFILE=${DOMAIN_HOME}/servers/${SERVER_NAME}/data/nodemanager/${SERVER_NAME}.state
    if [ `jps -l | grep -c " weblogic.NodeManager"` -eq 0 ]; then
      echo "Error: WebLogic NodeManager process not found."
      exit 1
    fi
    if [ -f ${STATEFILE} ] && [ `grep -c "FAILED_NOT_RESTARTABLE" ${STATEFILE}` -eq 1 ]; then
      echo "Error: WebLogic Server state is FAILED_NOT_RESTARTABLE."
      exit 1
    fi
    exit 0

  readState.sh: |
    #!/bin/bash

    # Reads the current state of a server. The script checks a WebLogic Server state
    # file which is updated by the node manager.

    STATEFILE=${DOMAIN_HOME}/servers/${SERVER_NAME}/data/nodemanager/${SERVER_NAME}.state

    if [ `jps -l | grep -c " weblogic.NodeManager"` -eq 0 ]; then
      echo "Error: WebLogic NodeManager process not found."
      exit 1
    fi

    if [ ! -f ${STATEFILE} ]; then
      echo "Error: WebLogic Server state file not found."
      exit 2
    fi

    cat ${STATEFILE} | cut -f 1 -d ':'
    exit 0

  readinessProbe.sh: |
    #!/bin/bash

    # Kubernetes periodically calls this readiness probe script to determine whether
    # the pod should be included in load balancing. The script checks a WebLogic Server state
    # file which is updated by the node manager.

    STATEFILE=${DOMAIN_HOME}/servers/${SERVER_NAME}/data/nodemanager/${SERVER_NAME}.state

    if [ `jps -l | grep -c " weblogic.NodeManager"` -eq 0 ]; then
      echo "Error: WebLogic NodeManager process not found."
      exit 1
    fi

    if [ ! -f ${STATEFILE} ]; then
      echo "Error: WebLogic Server state file not found."
      exit 2
    fi

    state=$(cat ${STATEFILE} | cut -f 1 -d ':')
    if [ "$state" != "RUNNING" ]; then
      echo "Not ready: WebLogic Server state: ${state}"
      exit 3
    fi
    exit 0

  start-server.py: |+
    import sys;
    #
    # +++ Start of common code for reading domain secrets

    # Read username secret
    file = open('/weblogic-operator/secrets/username', 'r')
    admin_username = file.read()
    file.close()
    print('admin_username=' + admin_username)

    # Read password secret
    file = open('/weblogic-operator/secrets/password', 'r')
    admin_password = file.read()
    file.close()
    print('admin_password=' + admin_password)

    # +++ End of common code for reading domain secrets
    #
    server_name = os.environ['SERVER_NAME']
    domain_uid = os.environ['DOMAIN_UID']
    domain_name = os.environ['DOMAIN_NAME']
    domain_home = os.environ['DOMAIN_HOME']
    admin_name = os.environ['ADMIN_NAME']
    admin_port = os.environ['ADMIN_PORT']

    print 'admin username is %s' % admin_username
    print 'admin password is %s' % admin_password
    print 'domain home is %s' % domain_home
    print 'server name is %s' % server_name
    if server_name != admin_name:
      admin_server_url='t3://' + domain_uid + '-' + admin_name + ':' + admin_port
      print 'admin server url is %s' % admin_server_url

    # Encrypt the admin username and password
    adminUsernameEncrypted=encrypt(admin_username, domain_home)
    adminPasswordEncrypted=encrypt(admin_password, domain_home)

    print 'Create boot.properties files for this server'

    # Define the folder path
    secdir='%s/servers/%s/security' % (domain_home, server_name)

    # Create the security folder (if it does not already exist)
    try:
      os.makedirs(secdir)
    except OSError:
      if not os.path.isdir(secdir):
        raise

    print 'writing boot.properties to %s/servers/%s/security/boot.properties' % (domain_home, server_name)

    bpFile=open('%s/servers/%s/security/boot.properties' % (domain_home, server_name), 'w+')
    # bpFile.write("username=%s\n" % adminUsernameEncrypted)
    # bpFile.write("password=%s\n" % adminPasswordEncrypted)
    bpFile.write("username=%s\n" % admin_username)
    bpFile.write("password=%s\n" % admin_password)
    bpFile.close()

    service_name = domain_uid + "-" + server_name

    # Connect to nodemanager and start server
    try:
      nmConnect(admin_username, admin_password, service_name,  '5556', domain_name, domain_home, 'plain')
      nmStart(server_name)
      nmDisconnect()
    except WLSTException, e:
      nmDisconnect()
      print e

    # Exit WLST
    exit()

  startServer.sh: |+
    #!/bin/bash

    local_nmdir=/u01/nodemanager

    # Create a folder
    # $1 - path of folder to create
    function createFolder {
      mkdir -m 777 -p $1
      if [ ! -d $1 ]; then
        fail "Unable to create folder $1"
      fi
    }

    # Function to create server specific scripts and properties (e.g startup.properties, etc)
    function createServerScriptsProperties() {
      local_nmdir=$1

      # Create startup.properties file
      datadir=${DOMAIN_HOME}/servers/${SERVER_NAME}/data/nodemanager
      stateFile=${datadir}/${SERVER_NAME}.state
      startProp=${datadir}/startup.properties
      if [ -f "$startProp" ]; then
        echo "startup.properties already exists"
        return 0
      fi

      createFolder ${datadir}
      echo "# Server startup properties" > ${startProp}
      echo "AutoRestart=true" >> ${startProp}
      if [ "${SERVER_NAME}" != "${ADMIN_NAME}" ]; then
        echo "AdminURL=http\://${DOMAIN_UID}-${ADMIN_NAME}\:${ADMIN_PORT}" >> ${startProp}
      fi
      echo "RestartMax=2" >> ${startProp}
      echo "RotateLogOnStartup=false" >> ${startProp}
      echo "RotationType=bySize" >> ${startProp}
      echo "RotationTimeStart=00\:00" >> ${startProp}
      echo "RotatedFileCount=100" >> ${startProp}
      echo "RestartDelaySeconds=0" >> ${startProp}
      echo "FileSizeKB=5000" >> ${startProp}
      echo "FileTimeSpanFactor=3600000" >> ${startProp}
      echo "RestartInterval=3600" >> ${startProp}
      echo "NumberOfFilesLimited=true" >> ${startProp}
      echo "FileTimeSpan=24" >> ${startProp}
      echo "NMHostName=${DOMAIN_UID}-${SERVER_NAME}" >> ${startProp}
    }

    # Function to create a local copy of the node manager home
    function createLocalNodeManagerHome() {
      local_nmdir=$1

      # Create nodemanager home directory that is local to the k8s node
      mkdir -p ${local_nmdir}

      # totally take control of the node manager configuration
      nm_props=${local_nmdir}/nodemanager.properties
      nm_domains=${local_nmdir}/nodemanager.domains

      echo "#Node manager properties" > ${nm_props}
      echo "DomainsFile=${nm_domains}" >> ${nm_props}
      echo "LogLimit=0" >> ${nm_props}
      echo "DomainsDirRemoteSharingEnabled=true" >> ${nm_props}
      echo "PropertiesVersion=12.2.1" >> ${nm_props}
      echo "AuthenticationEnabled=true" >> ${nm_props}
      echo "NodeManagerHome=${local_nmdir}" >> ${nm_props}
      echo "JavaHome=/usr/java/jdk1.8.0_151/Contents/Home" >> ${nm_props}
      echo "LogLevel=FINEST" >> ${nm_props}
      echo "DomainsFileEnabled=true" >> ${nm_props}
      echo "ListenAddress=${DOMAIN_UID}-${SERVER_NAME}" >> ${nm_props}
      echo "NativeVersionEnabled=true" >> ${nm_props}
      echo "ListenPort=5556" >> ${nm_props}
      echo "LogToStderr=true" >> ${nm_props}
      echo "weblogic.StartScriptName=startWebLogic.sh" >> ${nm_props}
      echo "SecureListener=false" >> ${nm_props}
      echo "LogCount=1" >> ${nm_props}
      echo "QuitEnabled=false" >> ${nm_props}
      echo "LogAppend=true" >> ${nm_props}
      echo "weblogic.StopScriptEnabled=false" >> ${nm_props}
      echo "StateCheckInterval=500" >> ${nm_props}
      echo "CrashRecoveryEnabled=true" >> ${nm_props}
      echo "weblogic.StartScriptEnabled=false" >> ${nm_props}
      echo "LogFile=${DOMAIN_LOGS}/nodemanager-${SERVER_NAME}.log" >> ${nm_props}
      echo "LogFormatter=weblogic.nodemanager.server.LogFormatter" >> ${nm_props}
      echo "ListenBacklog=50" >> ${nm_props}

      echo "#Domains and directories created by Configuration Wizard" > ${nm_domains}
      echo "${DOMAIN_NAME}=${DOMAIN_HOME}" >> ${nm_domains}

      cp ${DOMAIN_HOME}/bin/startNodeManager.sh ${local_nmdir}
      sed -i -e "s:${DOMAIN_HOME}/nodemanager:${local_nmdir}:g" ${local_nmdir}/startNodeManager.sh
    }

    # Check for stale state file and remove if found"
    if [ -f "$stateFile" ]; then
      echo "Removing stale file $stateFile"
      rm ${stateFile}
    fi

    # Create a node manager home local to this pod
    createLocalNodeManagerHome ${local_nmdir}
    export JAVA_PROPERTIES="-DLogFile=${DOMAIN_LOGS}/nodemanager-${SERVER_NAME}.log -DNodeManagerHome=${local_nmdir}"
    export NODEMGR_HOME="${local_nmdir}"

    # Create startup.properties
    echo "Create startup.properties"
    createServerScriptsProperties ${local_nmdir}

    echo "Start the nodemanager"
    . ${NODEMGR_HOME}/startNodeManager.sh &

    echo "Allow the nodemanager some time to start before attempting to connect"
    sleep 15
    echo "Finished waiting for the nodemanager to start"

    echo "Update JVM arguments"
    echo "Arguments=${USER_MEM_ARGS} -XX\:+UnlockExperimentalVMOptions -XX\:+UseCGroupMemoryLimitForHeap ${JAVA_OPTIONS}" >> ${startProp}

    echo "Copy the generated situational config to the domain home"
    mkdir ${DOMAIN_HOME}/optconfig
    cp /weblogic-operator/domain-bindings/operator-situational-config.xml ${DOMAIN_HOME}/optconfig

    echo "Start the server"
    wlst.sh -skipWLSModuleScanning /weblogic-operator/scripts/start-server.py ${DOMAIN_UID}

    cat ${DOMAIN_HOME}/servers/${SERVER_NAME}/security/boot.properties

    echo "Wait indefinitely so that the Kubernetes pod does not exit and try to restart"
    while true; do sleep 60; done

  stop-server.py: |+
    #
    # +++ Start of common code for reading domain secrets

    # Read username secret
    file = open('/weblogic-operator/secrets/username', 'r')
    admin_username = file.read()
    file.close()

    # Read password secret
    file = open('/weblogic-operator/secrets/password', 'r')
    admin_password = file.read()
    file.close()

    # +++ End of common code for reading domain secrets
    #
    server_name = os.environ['SERVER_NAME']
    domain_uid = os.environ['DOMAIN_UID']
    domain_name = os.environ['DOMAIN_NAME']
    domain_home = os.environ['DOMAIN_HOME']

    service_name = domain_uid + "-" + server_name

    # Connect to nodemanager and stop server
    try:
      nmConnect(admin_username, admin_password, service_name,  '5556', domain_name, domain_home, 'plain')
    except:
      print('Failed to connect to the NodeManager')
      exit(exitcode=2)

    # Kill the server
    try:
      nmKill(server_name)
    except:
      print('Connected to the NodeManager, but failed to stop the server')
      exit(exitcode=2)

    # Exit WLST
    nmDisconnect()
    exit()

  stopServer.sh: |+
    #!/bin/bash

    echo "Stop the server"

    wlst.sh -skipWLSModuleScanning /weblogic-operator/scripts/stop-server.py ${DOMAIN_UID}

    # Return status of 2 means failed to stop a server through the NodeManager.
    # Look to see if there is a server process that can be killed.
    if [ $? -eq 2 ]; then
      pid=$(jps -v | grep '[D]weblogic.Name=$2' | awk '{print $1}')
      if [ ! -z $pid ]; then
        echo "Killing the server process $pid"
        kill -15 $pid
      fi
    fi

  introspect-domain.py: |+

    #
    # +++ Start of common utilities

    def writeln(f, v):
      f.write(v + "\n")

    # +++ Start of common utilities
    #


    #
    # +++ Start of domain validation

    def validateDomain():
      # TBD - move the assertions below from creating topology here
      # and print errors to a file and return false if anything is wrong
      # TBD - should we write it to the topology file instead?
      # TBD - is it really just true/false, or do we print warnings and ignore?
      return True

    # +++ Start of domain validation
    #

    #
    # +++ Start of topology generation

    def addAdminServerTopology(f):
      admin_name=cmo.getAdminServerName()
      admin_server=None
      for server in cmo.getServers():
        if admin_name == server.getName():
          admin_server = server
          # TBD - assert that the admin server is not clustered
          break
      # TBD - assertion for admin_server is not None ?
      writeln(f, "      adminServer: \"" + admin_server.getName() + "\"")

    def findDynamicClusterServerTemplate(f, cluster):
      # find the server template for this cluster
      server_template=None
      for template in cmo.getServerTemplates():
        if template.getCluster() is cluster:
          # assert that there is only server template for this cluster
          assert server_template is None
          server_template = template
      assert server_template is not None
      return server_template

    def addDynamicClusterTopology(f, cluster):
      # make sure that there are no servers using this cluster
      for server in cmo.getServers():
        assert server.getCluster() is not cluster
      dyn_servers = cluster.getDynamicServers()
      assert dyn_servers.isCalculatedListenPorts() == False
      server_template = findDynamicClusterServerTemplate(f, cluster)
      writeln(f, "      - name: \"" + cluster.getName() + "\"")
      writeln(f, "        port: " + str(server_template.getListenPort()))
      writeln(f, "        maxServers: " + str(dyn_servers.getMaxDynamicClusterSize()))
      writeln(f, "        baseServerName: \"" + dyn_servers.getServerNamePrefix() + "\"")

    def addDynamicClustersTopology(f):
      writeln(f, "      dynamicClusters:")
      for cluster in cmo.getClusters():
        if cluster.getDynamicServers() is not None:
          addDynamicClusterTopology(f, cluster)

    # all the servers in the non-dynamic cluster must have the same port number
    # TBD - can/should we support per-server port numbers?
    def findNonDynamicClusterPort(f, cluster):
      cluster_port=None
      for server in cmo.getServers():
        if server.getCluster() is cluster:
          port=server.getListenPort()
          if cluster_port is None:
            cluster_port=port
          else:
            assert port == cluster_port
      assert cluster_port is not None # i.e. that we have at least one server in the cluster
      return cluster_port

    def addClusteredServerTopology(f, server):
      writeln(f, "        - name: \"" + server.getName() + "\"")

    def addNonDynamicClusterTopology(f, cluster):
      # make sure that there are no server templates using this cluster
      for template in cmo.getServerTemplates():
        assert template.getCluster() is not cluster
      writeln(f, "      - name: \"" + cluster.getName() + "\"")
      writeln(f, "        port: \"" + str(findNonDynamicClusterPort(f, cluster)))
      writeln(f, "        servers:")
      for server in cmo.getServers():
        if server.getCluster() is cluster:
          addClusteredServerTopology(f, server)

    def addNonDynamicClustersTopology(f):
      writeln(f, "      nonDynamicClusters:")
      for cluster in cmo.getClusters():
        if cluster.getDynamicServers() is None:
          addNonDynamicClusterTopology(f, cluster)

    def addNonClusteredServerTopology(f, server):
      writeln(f, "      - name: \"" + server.getName() + "\"")
      writeln(f, "        port: " + str(server.getListenPort()))

    def addNonClusteredServersTopology(f):
      writeln(f, "      servers:")
      for server in cmo.getServers():
        if server.getCluster() is None:
          addNonClusteredServerTopology(f, server)

    def addDomainTopology(f):
      writeln(f, "    domain")
      writeln(f, "      name: \"" + cmo.getName() + "\"")

    def createTopology(f):
      cd('/')
      addDomainTopology(f)
      addAdminServerTopology(f)
      addDynamicClustersTopology(f)
      addNonDynamicClustersTopology(f)
      addNonClusteredServersTopology(f)

    # +++ End of topology generation
    #

    #
    # +++ Start of situational configuration generation

    def readSecret(path):
      file = open(path, 'r')
      secret = file.read()
      file.close()
      return secret

    def readAndEncryptSecret(path):
      secret = readSecret(path)
      domain_home=os.environ['DOMAIN_HOME']
      return encrypt(secret, domain_home)

    def beginDomain(f):
      writeln(f, "    <?xml version='1.0' encoding='UTF-8'?>")
      writeln(f, "    <d:domain xmlns:d=\"http://xmlns.oracle.com/weblogic/domain\" xmlns:f=\"http://xmlns.oracle.com/weblogic/domain-fragment\" xmlns:s=\"http://xmlns.oracle.com/weblogic/situational-config\">")
      writeln(f, "      <s:expiration> 2020-07-16T19:20+01:00 </s:expiration>")
      # TODO - get this working:
      #admin_username = readSecret('/weblogic-operator/secrets/username')
      #admin_password = readAndEncryptSecret('/weblogic-operator/secrets/password')
      #writeln(f, "      <d:security-configuration>")
      #writeln(f, "        <d:node-manager-user-name f:combine-mode=\"replace\">" + admin_username + "</d:node-manager-user-name>")
      #writeln(f, "        <d:node-manager-password-encrypted f:combine-mode=\"replace\">" + admin_password + "</d:node-manager-password-encrypted>")
      #writeln(f, "      <d:/security-configuration>")
      domain_name=cmo.getName()
      writeln(f, "      <d:log f:combine-mode=\"replace\">")
      writeln(f, "        <d:file-name>/domain-logs/" + domain_name + ".log</d:file-name>")
      writeln(f, "      </d:log>")

    def endDomain(f):
      writeln(f, "    </d:domain>")

    def customizeServer(f, domain_uid, admin_server_name, server):
      name=server.getName()
      writeln(f, "      <d:server>")
      writeln(f, "        <d:name>" + name + "</d:name>")
      writeln(f, "        <d:log f:combine-mode=\"replace\">")
      writeln(f, "          <d:file-name>/domain-logs/" + name + ".log</d:file-name>")
      writeln(f, "        </d:log>")
      writeln(f, "        <d:listen-address f:combine-mode=\"replace\">" + domain_uid + "-" + name + "</d:listen-address>")
      if name == admin_server_name:
        # TBD - find the t3 channel, and if it exists, customize its listen address
        writeln(f, "        <d:network-access-point>")
        writeln(f, "          <d:name>T3Channel</d:name>") # TBD - needs to be discovered, v.s. depending on a fixed name
        writeln(f, "          <d:listen-address f:combine-mode=\"replace\">" + domain_uid + "-" + name + "</d:listen-address>")
        writeln(f, "        </d:network-access-point>")
      writeln(f, "      </d:server>")

    def customizeServerTemplate(f, domain_uid, template):
      name=template.getName()
      server_name_prefix=template.getCluster().getDynamicServers().getServerNamePrefix()
      writeln(f, "      <d:server-template>")
      writeln(f, "        <d:name>" + name + "</d:name>")
      writeln(f, "        <d:log f:combine-mode=\"replace\">")
      writeln(f, "          <d:file-name>/domain-logs/" + server_name_prefix + "\${i}.log</d:file-name>")
      writeln(f, "        </d:log>")
      #writeln(f, "        <d:listen-address f:combine-mode=\"replace\">" + domain_uid + "-" + server_name_prefix + "\${i}</d:listen-address>")
      writeln(f, "      </d:server-template>")

    def createSitConfig(f):
      domain_uid=os.environ['DOMAIN_UID']
      cd('/')
      admin_server_name=cmo.getAdminServerName()
      beginDomain(f)
      for server in cmo.getServers():
        customizeServer(f, domain_uid, admin_server_name, server)
      for template in cmo.getServerTemplates():
        customizeServerTemplate(f, domain_uid, template)
      endDomain(f)

    # +++ End of situational configuration generation
    #

    # +++ Start of overall config map generation

    def addConfigMapHeader(f):
      domain_uid=os.environ['DOMAIN_UID']
      domain_name=cmo.getName()
      writeln(f, "apiVersion: v1")
      writeln(f, "kind: ConfigMap")
      writeln(f, "metadata:")
      writeln(f, "  labels:")
      writeln(f, "    weblogic.createdByOperator: \"true\"")
      writeln(f, "    weblogic.domainName: " + domain_name)
      writeln(f, "    weblogic.domainUID: " + domain_uid)
      writeln(f, "    weblogic.resourceVersion: domain-v1")
      writeln(f, "  name: " + domain_uid + "-weblogic-domain-bindings-cm")
      writeln(f, "  namespace: %DOMAIN_NAMESPACE%")

    def endConfigMap(f):
      undent()

    def addFileHeaderToConfigMap(f, name):
      writeln(f, "  " + name + ": |")

    def addTopologyToConfigMap(f):
      addFileHeaderToConfigMap(f, "topology.yaml")
      createTopology(f)

    def addSitConfigToConfigMap(f):
      addFileHeaderToConfigMap(f, "operator-situational-config.xml")
      createSitConfig(f)

    def addFilesToConfigMap(f):
      writeln(f, "data:")
      addTopologyToConfigMap(f)
      addSitConfigToConfigMap(f)

    def createConfigMap():
      config_map_path=sys.argv[1]
      f=open(config_map_path, 'w+')
      addConfigMapHeader(f)
      addFilesToConfigMap(f)
      f.close()

    def main():
      domain_home=os.environ['DOMAIN_HOME']
      readDomain(domain_home)
      if validateDomain() == True:
        createConfigMap()
      closeDomain()
      exit()

    main()

  introspectDomain.sh: |+
    #!/bin/bash
    echo "Introspect the domain"
    CONFIG_MAP="/u01/domain-introspection-results.yaml"
    rm -f ${CONFIG_MAP}
    wlst.sh -skipWLSModuleScanning /weblogic-operator/scripts/introspect-domain.py $CONFIG_MAP

    echo "Wait indefinitely so that the Kubernetes pod does not exit and try to restart"
    while true; do sleep 60; done
    exit 0

  introspectionReadinessProbe.sh: |+
    #!/bin/bash
    CONFIG_MAP="/u01/domain-introspection-results.yaml"
    if [ -f $CONFIG_MAP ]; then
      exit 0
    else
      echo "Not ready : ${CONFIG_MAP} not found."
      exit 1
    fi

  introspectionLivenessProbe.sh: |+
    #!/bin/bash
    CONFIG_MAP="/u01/domain-introspection-results.yaml"
    if [ -f $CONFIG_MAP ]; then
      exit 0
    else
      echo "Error : ${CONFIG_MAP} not found."
      exit 1
    fi

  getIntrospectionResults.sh: |+
    #!/bin/bash
    CONFIG_MAP="/u01/domain-introspection-results.yaml"
    if [ -f ${CONFIG_MAP} ]; then
      cat ${CONFIG_MAP}
      exit 0
    else
      echo "Error : ${CONFIG_MAP} not found."
      exit 1
    fi

kind: ConfigMap
metadata:
  labels:
    weblogic.createdByOperator: "true"
    weblogic.operatorName: %OPERATOR_NAMESPACE%
    weblogic.resourceVersion: domain-v1
  name: weblogic-domain-cm
  namespace: %DOMAIN_NAMESPACE%
